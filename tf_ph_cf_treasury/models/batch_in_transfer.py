# -*- encoding: utf-8 -*-
##############################################################################
#
# Copyright (c) 2020 Taliform Inc.
#
# Author: Bamboo <martin@taliform.com>
#
# WARNING: This program as such is intended to be used by professional
# programmers who take the whole responsibility of assessing all potential
# consequences resulting from its eventual inadequacies and bugs
#
# This program is Free Software; you can redistribute it and/or
# modify it under the terms of the GNU Affero General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
##############################################################################
from odoo import api, fields, models
from odoo.exceptions import ValidationError, UserError


class TfAccountBatchInternalTransfer(models.Model):
    _name = 'tf.account.batch.internal.transfer'
    _description = "Batch Internal Transfer"
    _inherit = ['mail.thread', 'mail.activity.mixin', 'portal.mixin']
    _order = 'create_date desc, id desc'

    _STATES = [
        ('draft', "Draft"),
        ('confirm', "Confirm"),
        ('generate', "Generated"),
        ('validate', "Validated"),
        ('cancel', "Cancel")
    ]

    name = fields.Char("Reference", default="Draft Transfer", readonly="1", copy=False, tracking=True,
                       help="Indicates the unique identifier for the Batch Internal Transfer record")
    state = fields.Selection(_STATES, default='draft', copy=False, tracking=True, readonly=True,
                             help="Indicates the state of the Batch Internal Transfer")
    origin_journal_id = fields.Many2one(
        'account.journal', "Origin Journal", tracking=True, required=True,
        domain=[('for_undeposited_payment', '=', True), ('type', 'in', ['bank', 'cash'])],
        help="Indicates the internal transfer's journal of origin")
    destination_journal_id = fields.Many2one(
        'account.journal', "Destination Journal", tracking=True, required=True,
        domain=[('for_undeposited_payment', '=', False), ('type', 'in', ['bank', 'cash'])],
        help="Indicates the internal transfer's destination journal")
    origin_payment_ids = fields.Many2many(
        'account.payment', 'batch_origin_payment_rel', 'payment_id', 'batch_id', string='Payments', tracking=True,
        domain="[('is_transferred', '=', False),('journal_id', '=', origin_journal_id),"
               "('state','not in',['draft','cancelled']),('payment_type','=','inbound')]")
    generated_payment_ids = fields.Many2many(
        'account.payment', 'batch_generated_payment_rel', 'payment_id', 'batch_id',
        string='Internal Transfer Payments', tracking=True)
    confirm_uid = fields.Many2one('res.users', "Confirmed By", readonly=True, copy=False,
                                  help="Indicates the user who confirmed the transfer.")
    generate_uid = fields.Many2one('res.users', "Generated By", readonly=True, copy=False,
                                   help="Indicates the user who generated the transfer payments.")
    validate_uid = fields.Many2one('res.users', "Validated By", readonly=True, copy=False,
                                   help="Indicates the user who validated the transfer.")
    confirm_date = fields.Datetime("Confirmation Date", readonly=True, copy=False, tracking=True)
    generate_date = fields.Datetime("Generation Date", readonly=True, copy=False, tracking=True)
    validate_date = fields.Datetime("Validation Date", readonly=True, copy=False, tracking=True)
    generated_nbr = fields.Integer("Generated Payments", compute='_count_generated_nbr', store=True)

    @api.onchange('origin_journal_id')
    def onchange_origin_journal_id(self):
        for rec in self:
            rec.origin_payment_ids = False

    @api.depends('generated_payment_ids')
    def _count_generated_nbr(self):
        for rec in self:
            rec.generated_nbr = len(rec.generated_payment_ids)

    def unlink(self):
        if self.filtered(lambda x: x.name != 'Draft Transfer'):
            raise UserError('You may not delete a confirmed transfer. Instead, you may cancel the transfer.')
        return super(TfAccountBatchInternalTransfer, self).unlink()

    def action_cancel(self):
        for rec in self:
            if rec.state == 'draft' and rec.name == 'Draft Transfer':
                rec.unlink()
            elif rec.sstate == 'confirm':
                rec.state = 'cancel'
            elif rec.state == 'generate':
                rec.generated_payment_ids.unlink()
                rec.state = 'cancel'

    def action_generate(self):
        today = fields.Date.context_today(self)
        ap_obj = self.env['account.payment']
        manual_method_id = self.env.ref('account.account_payment_method_manual_in').id

        for rec in self:
            origin_journal_id = rec.origin_journal_id.id
            destination_journal_id = rec.destination_journal_id.id
            generated_payment_ids = []

            for payment_id in rec.origin_payment_ids:
                if payment_id.is_transferred:
                    raise ValidationError(
                        "Payment (%s) has already been transferred in internal transfer (%s)."
                        % (payment_id.name, payment_id.counter_in_transfer_id.name)
                    )

                ap_vals = {
                    'payment_type': 'transfer',
                    'payment_method_id': manual_method_id,
                    'journal_id': origin_journal_id,
                    'destination_journal_id': destination_journal_id,
                    'payment_date': today,
                    'amount': payment_id.amount,
                    'check_no': payment_id.check_no,
                    'counter_in_transfer_id': payment_id.id,
                    'communication': payment_id.communication,
                    'currency_id': payment_id.currency_id.id,
                }
                payment_id = ap_obj.create(ap_vals)
                generated_payment_ids.append(payment_id.id)

            rec.write({
                'state': 'generate',
                'generated_payment_ids': [(6, 0, generated_payment_ids)]
            })

    def action_view_generated(self):
        self.ensure_one()
        return {
            'name': 'Generated Internal Transfers',
            'view_mode': 'tree,kanban,form,graph',
            'res_model': 'account.payment',
            'domain': [('id', 'in', self.generated_payment_ids.ids)],
            'views': [(self.env.ref('tf_ph_cf_treasury.tf_account_payment_tree_inherit_readonly').id, 'tree'),
                      (False, 'form'),
                      (False, 'kanban'),
                      (False, 'graph')],
            'type': 'ir.actions.act_window',
            'target': 'current'
        }

    def action_confirm(self):
        sequence_obj = self.env['ir.sequence']
        for rec in self:
            vals = {
                'state': 'confirm',
                'confirm_uid': self._uid,
                'confirm_date': fields.Datetime.now()
            }
            if rec.name == 'Draft Transfer':
                vals.update({'name': sequence_obj.sudo().next_by_code('account.batch.internal.transfer')})
            rec.write(vals)
        return self

    def action_draft(self):
        self.write({'state': 'draft'})

    def action_validate(self):
        self.generated_payment_ids.filtered_domain([('state', '=', 'draft')]).post()
        self.write({'state': 'validate'})
